---
title: shell 脚本note
date: 2018-07-30 10:30:49
categories: 工具箱
tags:
    - shell
    - 脚本
---

# Shell中逻辑运算

常见错误
``` bash
-bash: [: missing `]' # [ 1 -gt 1 ] 括号两边都要有空格，不然就报这个错
```

## 一、逻辑运算符

### 1.关于档案与目录的侦测逻辑卷标！
| 逻辑卷标 | 表示意思                                          |
| -------- | ------------------------------------------------- |
| -f       | 常用！侦测『档案』是否存在 eg: if [ -f filename ] |
| -d       | 常用！侦测『目录』是否存在                        |
| -b       | 侦测是否为一个『 block 档案』                     |
| -c       | 侦测是否为一个『 character 档案』                 |
| -S       | 侦测是否为一个『 socket 标签档案』                |
| -L       | 侦测是否为一个『 symbolic link 的档案』           |
| -e       | 侦测『某个东西』是否存在！                        |

### 2.关于程序的逻辑卷标！

| 逻辑卷标 | 表示意思                                                                |
| -------- | ----------------------------------------------------------------------- |
| -G       | 侦测是否由 GID 所执行的程序所拥有                                       |
| -O       | 侦测是否由 UID 所执行的程序所拥有                                       |
| -p       | 侦测是否为程序间传送信息的 name pipe 或是 FIFO （老实说，这个不太懂！） |

### 3.关于档案的属性侦测！

| 逻辑卷标 | 表示意思                           |
| -------- | ---------------------------------- |
| -r       | 侦测是否为可读的属性               |
| -w       | 侦测是否为可以写入的属性           |
| -x       | 侦测是否为可执行的属性             |
| -s       | 侦测是否为『非空白档案』           |
| -u       | 侦测是否具有『 SUID 』的属性       |
| -g       | 侦测是否具有『 SGID 』的属性       |
| -k       | 侦测是否具有『 sticky bit 』的属性 |

### 4.两个档案之间的判断与比较 ；例如[ test file1 -nt file2 ]

| 逻辑卷标 | 表示意思                                               |
| -------- | ------------------------------------------------------ |
| -nt      | 第一个档案比第二个档案新                               |
| -ot      | 第一个档案比第二个档案旧                               |
| -ef      | 第一个档案与第二个档案为同一个档案（ link 之类的档案） |

### 5.逻辑的『和(and)』『或(or)』

| 逻辑卷标 | 表示意思          |
| -------- | ----------------- |
| &&       | 逻辑的 AND 的意思 |
| \|\|     | 逻辑的 OR 的意思  |

### 逻辑运算符

| 运算符号 | 代表意义                                                    |
| -------- | ----------------------------------------------------------- |
| =        | 等于 应用于：整型或字符串比较 (如果在[] 中，只能是字符串)   |
| !=       | 不等于 应用于：整型或字符串比较 (如果在[] 中，只能是字符串) |
| <        | 小于 应用于：整型比较 (在[] 中，不能使用 表示字符串 )       |
| >        | 大于 应用于：整型比较 (在[] 中，不能使用 表示字符串)        |
| -eq      | 等于 应用于：整型比较                                       |
| -ne      | 不等于 应用于：整型比较                                     |
| -lt      | 小于 应用于：整型比较                                       |
| -gt      | 大于 应用于：整型比较                                       |
| -le      | 小于或等于 应用于：整型比较                                 |
| -ge      | 大于或等于 应用于：整型比较                                 |
| -a       | 双方都成立（and） 逻辑表达式 –a 逻辑表达式                  |
| -o       | 单方成立（or） 逻辑表达式 –o 逻辑表达式                     |
| -z       | 空字符串                                                    |
| -n       | 非空字符串                                                  |

## 二、逻辑表达式

### test 命令
使用方法：test EXPRESSION

如：
``` bash
test 1 = 1 && echo 'ok'
ok
test -d /etc/ && echo 'ok' 
ok
test 1 -eq 1 && echo 'ok'
ok
if test 1 = 1 ; then echo 'ok'; fi
ok
```
注意：所有字符 与逻辑运算符直接用“空格”分开，不能连到一起。

### 精简表达式
[] 表达式
``` bash
[ 1 -eq 1 ] && echo 'ok'  # ok
[ 2 < 1 ] && echo 'ok'  # -bash: 1: No such file or directory
[ 2 \> 1 ] && echo 'ok'  # ok
[ 2 -gt 1 -a 3 -lt 4 ] && echo 'ok'  # ok
[ 2 -gt 1 && 3 -lt 4 ] && echo 'ok'  # 这么写不对 -bash: [: missing `]'
[ 2 -gt 1 ] && [ 3 -lt 4 ] && echo 'ok'  # ok
```
注意：在[] 表达式中，常见的`>` 和 `<`需要加转义字符，表示字符串大小比较，以acill码 位置作为比较。 不直接支持<>运算符，还有逻辑运算符|| && 它需要用-a[and] –o[or]表示

### [[]] 表达式

``` bash
[ 1 -eq 1 ] && echo 'ok' # ok
[[ 2 < 3 ]] && echo 'ok' # ok
[[ 2 < 3 && 4 < 5 ]] && echo 'ok'  # ok
```

注意：[[]] 运算符只是[]运算符的扩充。能够支持 `<` 和 `>` 符号运算不需要转义符，它还是以字符串比较大小。里面支持逻辑运算符：|| &&

## 三、性能比较

bash的条件表达式中有三个几乎等效的符号和命令：test，[]和[[]]。通常，大家习惯用if [];then这样的形式。而[[]]的出现，根据ABS所说，是为了兼容><之类的运算符。以下是比较它们性能，发现[[]]是最快的。

``` bash
time (for m in {1..100000}; do test -d .;done;)
#real    0m0.658s
#user    0m0.558s
#sys     0m0.100s

time (for m in {1..100000}; do [ -d . ];done;)
#real    0m0.609s
#user    0m0.524s
#sys     0m0.085s

time (for m in {1..100000}; do [[ -d . ]];done;)
#real    0m0.311s
#user    0m0.275s
#sys     0m0.036s
```
不考虑对低版本bash和对sh的兼容的情况下，用[[]]是兼容性强，而且性能比较快，在做条件运算时候，可以使用该运算符。

# shell脚本参数

$0 当前脚本的文件名

``` bash
if [ $# -gt 0 ]; then
    data=$1 
else
    data=`date +"%Y-%m-%d"`
fi
```

# 2>&1

配置spark每日例行任务时候，直接运行脚本可以输入spark任务的运行信息，可是一旦用crontab就不行了，原来spark的任务日志是linux“错误输出”，要加2>&1 才能从正常输出里面捕捉到，坑死了。

ref:[Linux 2>&1](https://www.cnblogs.com/zhenghongxin/p/7029173.html)

# 获取当前脚本的路径

``` bash
$(cd `dirname $0`;pwd)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# $() 和 `` 作用相同，字符串作为shell命令执行

# BASH_SOURCE[0] 等价于 BASH_SOURCE， 取得当前执行的shell文件所在的路径及文件名。
# 如/home/abc/test.sh 内容如下：

#!/bin/sh
echo "${BASH_SOURCE[0]}"
echo "${BASH_SOURCE]}"
echo "$( dirname "${BASH_SOURCE[0]}" )"
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
echo $DIR

# 若当前目录在/home/,执行source ./abc/test.sh, 则输出：
# ./abc/test.sh
# ./abc/test.sh
# ./abc/
# /home/abc
```
总之：
`DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )" `得到shell脚本文件所在完整路径（绝对路径）及文件名（无论source,sh,.三种调用方式），且不改变shell的当前目录。

------------------------------------------------------------------------------------------------------------------

# Linux 中的各种括号

参考：https://www.jb51.net/article/123081.htm

## 一、小括号，圆括号（）

1、单小括号 ()

①命令组。括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。括号中多个命令之间用分号隔开，最后一个命令可以没有分号，各命令和括号之间不必有空格。

②命令替换。等同于`cmd`，shell扫描一遍命令行，发现了$(cmd)结构，便将$(cmd)中的cmd执行一次，得到其标准输出，再将此输出放到原来命令。有些shell不支持，如tcsh。

③用于初始化数组。如：array=(a b c d)

2、双小括号 (( ))

①整数扩展。这种扩展计算是整数型的计算，不支持浮点型。((exp))结构扩展并计算一个算术表达式的值，如果表达式的结果为0，那么返回的退出状态码为1，或者 是"假"，而一个非零值的表达式所返回的退出状态码将为0，或者是"true"。若是逻辑判断，表达式exp为真则为1,假则为0。

②只要括号中的运算符、表达式符合C语言运算规则，都可用在$((exp))中，甚至是三目运算符。作不同进位(如二进制、八进制、十六进制)运算时，输出结果全都自动转化成了十进制。如：echo $((16#5f)) 结果为95 (16进位转十进制)

③单纯用 (( )) 也可重定义变量值，比如 a=5; ((a++)) 可将 $a 重定义为6

④常用于算术运算比较，双括号中的变量可以不使用 `$` 符号前缀。括号内支持多个表达式用逗号分开。 只要括号中的表达式符合C语言运算规则,比如可以直接使用`for((i=0;i<5;i++))`, 如果不使用双括号, 则为``` for i in `seq 0 4` ```或者```for i in {0..4}```。再如可以直接使用if (($i<5)), 如果不使用双括号, 则为if [ $i -lt 5 ]。


## 二、中括号，方括号[]

1、单中括号 []

①bash 的内部命令，[和test是等同的。如果我们不用绝对路径指明，通常我们用的都是bash自带的命令。if/test结构中的左中括号是调用test的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if/test结构中并不是必须右中括号，但是新版的Bash中要求必须这样。

②Test和[]中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq，-gt这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较"ab"和"bc"：[ ab \< bc ]，结果为真，也就是返回状态为0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示。

③字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。

④在一个array 结构的上下文中，中括号用来引用数组中每个元素的编号。

2、双中括号[[ ]]

①[[是 bash 程序语言的关键字。并不是一个命令，[[ ]] 结构比[ ]结构更加通用。在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。

②支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。

③使用[[ ... ]]条件判断结构，而不是[ ... ]，能够防止脚本中的许多逻辑错误。比如，&&、||、<和> 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。比如可以直接使用if [[ $a != 1 && $a != 2 ]], 如果不适用双括号, 则为if [ $a -ne 1] && [ $a != 2 ]或者if [ $a -ne 1 -a $a != 2 ]。

④bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。

例子：
``` bash
if ($i<5) 
if [ $i -lt 5 ] 
if [ $a -ne 1 -a $a != 2 ] 
if [ $a -ne 1] && [ $a != 2 ] 
if [[ $a != 1 && $a != 2 ]] 
for i in $(seq 0 4);do echo $i;done
for i in `seq 0 4`;do echo $i;done
for ((i=0;i<5;i++));do echo $i;done
for i in {0..4};do echo $i;done
```

## 三、大括号、花括号 {}

1、常规用法

①大括号拓展。(通配(globbing))将对大括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。第一种：对大括号中的以逗号分割的文件列表进行拓展。如 touch {a,b}.txt 结果为a.txt b.txt。第二种：对大括号中以点点（..）分割的顺序文件列表起拓展作用，如：touch {a..d}.txt 结果为a.txt b.txt c.txt d.txt

``` bash
ls {ex1,ex2}.sh 
# ex1.sh ex2.sh 
ls {ex{1..3},ex4}.sh 
# ex1.sh ex2.sh ex3.sh ex4.sh 
ls {ex[1-3],ex4}.sh 
# ex1.sh ex2.sh ex3.sh ex4.sh
```

②代码块，又被称为内部组，这个结构事实上创建了一个匿名函数 。与小括号中的命令不同，大括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。括号内的命令间用分号隔开，最后一个也必须有分号。{}的第一个命令和左括号之间必须要有一个空格。

2、几种特殊的替换结构

``` bash
${var:-string},${var:+string},${var:=string},${var:?string}
```
①${var:-string}和${var:=string}:若变量var为空，则用在命令行中用string来替换${var:-string}，否则变量var不为空时，则用变量var的值来替换${var:-string}；对于${var:=string}的替换规则和${var:-string}是一样的，所不同之处是${var:=string}若var为空时，用string替换${var:=string}的同时，把string赋给变量var： ${var:=string}很常用的一种用法是，判断某个变量是否赋值，没有的话则给它赋上一个默认值。

② ${var:+string}的替换规则和上面的相反，即只有当var不是空的时候才替换成string，若var为空时则不替换或者说是替换成变量 var的值，即空值。(因为变量var此时为空，所以这两种说法是等价的)

③${var:?string}替换规则为：若变量var不为空，则用变量var的值来替换${var:?string}；若变量var为空，则把string输出到标准错误中，并从脚本中退出。我们可利用此特性来检查是否设置了变量的值。

补充扩展：在上面这五种替换结构中string不一定是常值的，可用另外一个变量的值或是一种命令的输出。

3、四种模式匹配替换结构

模式匹配记忆方法：

- # 是去掉左边(在键盘上#在$之左边)
- % 是去掉右边(在键盘上%在$之右边)

#和%中的单一符号是最小匹配，两个相同符号是最大匹配。

``` bash
${var%pattern},${var%%pattern},${var#pattern},${var##pattern}
```

第一种模式：${variable%pattern}，这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最短的匹配模式
第二种模式： ${variable%%pattern}，这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式
第三种模式：${variable#pattern} 这种模式时，shell在variable中查找，看它是否一给的模式pattern开始，如果是，就从命令行把variable中的内容去掉左边最短的匹配模式
第四种模式： ${variable##pattern} 这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式

这四种模式中都不会改变variable的值，其中，只有在pattern中使用了*匹配符号时，%和%%，#和##才有区别。结构中的pattern支持通配符，*表示零个或多个任意字符，?表示仅与一个任意字符匹配，[...]表示匹配中括号里面的字符，[!...]表示不匹配中括号里面的字符。
``` bash
# var=testcase 
# echo $var 
testcase 
# echo ${var%s*e} 
testca 
# echo $var 
testcase 
# echo ${var%%s*e} 
te 
# echo ${var#?e} 
stcase 
# echo ${var##?e} 
stcase 
# echo ${var##*e}
# echo ${var##*s} 
e 
# echo ${var##test} 
case
```

4、字符串提取和替换
``` bash
${var:num},${var:num1:num2},${var/pattern/pattern},${var//pattern/pattern}
```
第一种模式：${var:num}，这种模式时，shell在var中提取第num个字符到末尾的所有字符。若num为正数，从左边0处开始；若num为负数，从右边开始提取字串，但必须使用在冒号后面加空格或一个数字或整个num加上括号，如${var: -2}、${var:1-3}或${var:(-2)}。

第二种模式：${var:num1:num2}，num1是位置，num2是长度。表示从$var字符串的第$num1个位置开始提取长度为$num2的子串。不能为负数。

第三种模式：${var/pattern/pattern}表示将var字符串的第一个匹配的pattern替换为另一个pattern。

第四种模式：${var//pattern/pattern}表示将var字符串中的所有能匹配的pattern替换为另一个pattern。

``` bash
var=/home/centos 
echo $var 
#/home/centos
echo ${var:5} 
#/centos
echo ${var: -6} 
#centos 
echo ${var:(-6)} 
#centos 
echo ${var:1:4} 
#home 
echo ${var/o/h} 
#/hhme/centos
echo ${var//o/h} 
#/hhme/cenths
```

## 四、符号$后的括号

（1）${a} 变量a的值, 在不引起歧义的情况下可以省略大括号。

（2）$(cmd) 命令替换，和`cmd`效果相同，结果为shell命令cmd的输，过某些Shell版本不支持$()形式的命令替换, 如tcsh。

（3）$((expression)) 和`exprexpression`效果相同, 计算数学表达式exp的数值, 其中exp只要符合C语言的运算规则即可, 甚至三目运算符和逻辑表达式都可以计算。

## 五、使用

1、多条命令执行

（1）单小括号，(cmd1;cmd2;cmd3) 新开一个子shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后可以没有分号。

（2）单大括号，{ cmd1;cmd2;cmd3;} 在当前shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后必须有分号, 第一条命令和左括号之间必须用空格隔开。

对{}和()而言, 括号中的重定向符只影响该条命令， 而括号外的重定向符影响到括号中的所有命令。

------------------------------------------------------------------------------------------------------------------

# Linux Shell中三种引号的用法及区别

Linux Shell中有三种引号，分别为双引号（" "）、单引号(' ')以及反引号(\` \`)。

单引号不进行替换，将字符串中所有字符作为普通字符输出，而反引号中字符串作为shell命令执行，并返回执行结果。具体含义如下：

- 双引号（" "）：对字符串中出现的 $, '', `和\ 进行替换，除此以外所有的字符都解释成字符本身。
- 单引号（' '）：不替换特殊字符（$,'',`和\），将字符串中所有字符作为普通字符输出。
- 反引号（\` \`）：字符串作为shell命令执行，并返回执行结果。

------------------------------------------------------------------------------------------------------------------

# Shell的for循环语句

第一类：数字性循环
``` shell
# 1
for((i=1;i<=10;i++));  
do   
echo $(expr $i \* 3 + 1);  
done  

# 2 
for i in $(seq 1 10)  
do   
echo $(expr $i \* 3 + 1);  
done   

# 3
for i in {1..10}  
do  
echo $(expr $i \* 3 + 1);  
done  

# 4
awk 'BEGIN{for(i=1; i<=10; i++) print i}'  
```

第二类：字符性循环

``` bash
# 1
for i in `ls`;  
do   
echo $i is file name\! ;  
done 

# 2
for i in $* ;  
do  
echo $i is input chart\! ;  
done  

# 3
for i in f1 f2 f3 ;  
do  
echo $i is appoint ;  
done  

# 4
list="rootfs usr data data2"  
for i in $list;  
do  
echo $i is appoint ;  
done  
```

第三类：路径查找
``` shell
for file in /proc/*;  
do  
echo $file is file path \! ;  
done  

for file in $(ls *.sh)  
do  
echo $file is file path \! ;  
done  
```
现在一般都使用for in结构，for in结构后面可以使用函数来构造范围，比如$()、这些，里面写一些查找的语法，比如ls test*，那么遍历之后就是输出文件名了。