---
title: 【设计模式】三种工厂模式及在c++中的实现
date: 2018-07-07 01:03:28
tags: 设计模式 工程模式 代码 宏定义
---

# 简单模式

工厂模式中最简单的一种，用比较简单的方式隐藏创建对象的细节，一般只需要告诉工厂类所需要的类型，工厂类就会返回需要的产品类，但客户端看到的只是产品的抽象对象，无需关心到底是返回了哪个子类。

客户端唯一需要知道的具体子类就是工厂子类。除了这点，基本是达到了依赖倒转原则的要求。

疑问：如果每次用工厂类创建的类型都不相同，这样修改起来的时候还是需要大量的替换。所以简单工厂模式一般应该于程序中大部分地方都只使用其中一种产品，工厂类也不用频繁创建产品类的情况。这样修改的时候只需要修改有限的几个地方即可。

![](http://p8vrqzrnj.bkt.clouddn.com/19100800-208864687d8a43c7afed3069bd0c3174.jpg)

客户只需要知道SimpleFactory就可以了，使用的时候也是使用的AbstractFactory，这样客户端只在第一次创建工厂的时候是知道具体的细节的，其他时候它都只知道AbstractFactory，这样就完美的达到了依赖倒转的原则。

## 常用的场景
例如部署多种数据库的情况，可能在不同的地方要使用不同的数据库，此时只需要在配置文件中设定数据库的类型，每次再根据类型生成实例，这样，不管下面的数据库类型怎么变化，在客户端看来都是只有一个AbstractProduct，使用的时候根本无需修改代码。提供的类型也可以用比较便于识别的字符串，这样不用记很长的类名，还可以保存为配置文件。

这样，每次只需要修改配置文件和添加新的产品子类即可。

所以简单工厂模式一般应用于多种同类型类的情况，将这些类隐藏起来，再提供统一的接口，便于维护和修改。

## 优点
1. 隐藏了对象创建的细节，将产品的实例化推迟到子类中实现。
2. 客户端基本不用关心使用的是哪个产品，只需要知道用哪个工厂就行了，提供的类型也可以用比较便于识别的字符串。
3. 方便添加新的产品子类，每次只需要修改工厂类传递的类型值就行了。
4. 遵循了依赖倒转原则。

## 缺点
1. 要求产品子类的类型差不多，使用的方法名都相同，如果类比较多，而所有的类又必须要添加一种方法，则会是非常麻烦的事情。或者是一种类另一种类有几种方法不相同，客户端无法知道是哪一个产品子类，也就无法调用这几个不相同的方法。
2. 每添加一个产品子类，都必须在工厂类中添加一个判断分支，这违背了开放-封闭原则。

https://www.cnblogs.com/cxjchen/p/3143633.html
https://blog.csdn.net/kuaipengfei_/article/details/49590727